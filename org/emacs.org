* no mouse, no menu
* use in nw and windows
* don't change the third lisp






* DONE version control
** git
1. git中除了第一次外，不提示输入密码：git config --global credential.helper store
2. git config user.email "xxx@xxx.com"
3. git config user.name "xxx"
   git通过ui来请求密码：(setenv "GIT_ASKPASS" "git-gui--askpass")
*** magit
**** shortcut
   - M-x magit-status switch to the status buffer of that repository 使用这个命令查看Git的状态，在git中的命令为git status
   - s to stage files 把untracked或者unstaged文件的状态改成stage模式，
   - c to commit (type in your commit message then C-c C-c to save the message and commit)  把所有staged文件都commit到索引仓库中
   - P P to do a git push Update remote refs along with associated objects
   - F F to do a git pull Fetch from and merge with another repository or a local branch
   - TAB  Toggle hidden status of current section 用来转换显示当前文件的一些信息
   - i ignore file this will add the filename to the .gitignore file. 忽略当前文件的版本控制，如一些临时文件
   - I ignore file this will add the file to .git/infor/exclude
   - C-h m Magit的使用帮助信息
     
**** magit-status buffer
    this buffer contains several lists of objects, matching to different states of objects in Git's repository:
    - unknown objects (untracked)
    - saved (stashed) objects.stash临时存储变更，为以备将来使用stash apply恢复
    - modified object, but not added to commit list (unstaged)
    - modified objects, added to commit list (staged)
    - committed changes, but not pushed to source repository (unpushed).
    Besides this, if lists staged & unstaged aren't exists, then all modified files are listed in list with status changed.
User can move between objects in list by using arrow keys, or keys n & p. Besides this, user can quickly move between groups of files with different states by using numerical keys: 1 (magit-jump-to-untracked), 2 (magit-jump-to-unstaged), 3 (magit-jump-to-staged) and 4 (magit-jump-to-unpushed).

	Some operations, that could be performed on objects, behave differently depending on state of object. For example, if you press the k key (magit-discard-item) on unknown object, then it will deleted, but if you press it on modified object, this will only lead to drop changes from that object. And if you'll apply it to the saved (stashed) change, then this change will deleted.

	If you don't want to delete unknown objects, and don't want to register them in repository, then you can ignore them with one of two defined commands: the i key (magit-ignore-item) will put current object into ignore list located in the .gitignore file, and the I key (magit-ignore-item-locally) will put current object into the .git/info/exclude file, that is used to ignore objects only in current repository. Besides this, if you'll specify prefix argument before pressing one of these keys, then commands will ask for name of file to ignore, and you can enter name or regular expression as answer.

	And, as usually, you can open current object by pressing the RET key (magit-visit-item).
	
**** Work with changes
	User can commit by using one of two commands — either c (magit-log-edit), or C (magit-add-log). They both open a new buffer, where user should enter description of change, but slightly differs in decoration of this description. For first command, user can enter description as free form text, while for second, buffer will contain name of files, so log will look like standard ChangeLog files.

	But I need to mention, that changes are committed differently, depending on the state of repository. If exists only list of modified (changed) objects, then these commands will commit changes for files in this list. If user wants to commit only some objects, then he need to move them into the list of objects to commit (staged), and perform commit only after this operation. To move object into commit list, user can use the s key(magit-stage-item), (for unknown (untracked) objects, this will add object into repository), and remove file from this list, user can with the u key (magit-unstage-item). To move all objects into commit list, we can use the S key (magit-stage-all), and to perform reverse operations — the U key (magit-unstage-all).To stage multiple items (files/directories), you can mark a region and simply press s.

	Besides this, the package also can save changes without committing them into repository, so user can apply them some time later. This is very useful, when you don't want to commit changes, but you want to perform some operation, that requires "clean" repository. You can save changes by executing the magit-stash command, that is bound to z key, and that puts changes into list of saved (stashed) changes. Than you can perform all needed operations, and after them, apply saved changes to repository (this is could be done by using the a key). And, as was mentioned above, you can delete saved changes using the k key.

	The magit package can display changes using several ways. To view changes in concrete object, we can use the TAB key (magit-toggle-section), that will display changes in current object. To hide changes, user can use the same key.

	To view changes, made in the current branch, user can press d key (magit-diff-working-tree), and after asking a name of branch, with which the comparison should be performed, it will create a new buffer, containing information between current version and given branch. To make comparison between two arbitrary branches (or tags), user can use the D key(magit-diff), which will ask for name of two branches, and perform comparison. To scroll the content of buffer, user can use keys SPC (scroll down) and DEL (scroll up).

	And if user wants, he could return to the clear state of repository by discarding the changes with the x key(magit-reset-head), that will rollback repository to the given changeset (by default this is last committed changeset). There is also magit-reset-working-tree command (the X key), that will revert changes and return repository to the last committed change, without asking for name of changeset.

**** Work with history of changes
	To see history of changes in repository, user can use either l key (magit-log-head), or L key (magit-log). First command displays history of changes for current branch of development, while second, displays history for range, that it asks from user. Example of output, produced by these commands, you can see on the picture below. I want to mention, that magit tries to display changes in different branches, like the gitk command do.

	When moving along the history of changes, user can get detailed information about changeset under point by pressing the RET key. Besides this, user can view changes between any two changesets. To do this, he need to move to first changeset and mark it with the . key (magit-mark-item), and than, move to the other changeset, and display the changes by pressing the = key (magit-diff-with-mark). This will create a new buffer, where corresponding information will displayed.

	User can execute different commands on changesets. Using the a key (magit-apply-item) he can apply current changeset (changeset under point) to current branch of development. But he will need to explicitly commit new changes, or use the A key (magit-cherry-pick-item), that will also apply current changeset, but also will automatically commit changes to repository. And to revert changes, done in changeset under point, user can use the v key (magit-revert-item), that will apply patch in revert order.

	Besides working with history of changes for whole repository, user can also look changesets in local history (reflog). To do this, he can use either h key (magit-reflog-head), that displays reflog for current branch of development, or H key (magit-reflog), that displays changesets for any two points in local history. Both commands create a new buffer, in which user can execute commands, described above.

	There is also set of commands, that allows user to rewrite history of changes. This set of commands is more handy than combination of x (reset head) and a (cherry pick). All commands in this set have r as common prefix. To start work, you need to press r s, and you will asked for name of revision, starting from which you can start rewriting. And all following changesets will put into special list of pending changes. Than you can use a, A & v keys to apply and revert changes in order, that you need. And applied changesets will change their status from * to . (dot). You can also explicitly change status of changeset with r . and r * keys.

	If something goes wrong, you can return to start of work by pressing r a, and work will started from the revision, those name you enter with r s. And you can finish work by pressing r f, that will apply rest of changeset in the same order, as they were in the history of changes.

**** Tags, branches, and remote repositories
	The magit package also provides enough set of commands for work with branches, tags & remote repositories, so almost all operations could be performed from the Emacs.

	To create tags user can use keys t (magit-tag) and T (magit-annotated-tag). They both ask user for a name of tag, but the second command will also ask for more detailed description of the tag, so it could be much easier to find it later. After entering of tag's name, package will create tag with given name, and using current repository state.

	Work with branches is also simple. To create a new branch (and switching to it) user can use B key (magit-create-branch) — it will ask user for a name of the new branch. To switching between existing branches, user can use b key (magit-checkout), that will ask for name of the existing branch (you can use name completion) and will switch to given branch. And to perform git rebase user can use the R key (magit-rebase-step).

	We can merge the changes between the branches. To perform automatic merge of changes from given branch, user can use the M key (magit-automatic-merge), that will perform all missing changesets, and commit them into repository. And if you want to review changes before merging, then you can use the m key (magit-manual-merge). Both these commands accept name of branch as an argument.

	There are also several commands to work with remote repositories. The f key (magit-remote-update) gets from remote (origin) repository list of changesets, missing in current repository. These changes could be downloaded and applied with the F key (magit-pull). Besides this, if user did right customization of repository, then user can also use P key (magit-push) to push changesets into remote repository (currently, supported only pushing into origin.

**** Some time ago, the support of the git svn was added to the package. If current repository was created from the Subversion, then user will get access to the two additional commands: N r (magit-svn-rebase) will perform git svn rebase command, that performs synchronisation with the Subversion, and N c (magit-svn-dcommit), that will push your changesets from the Git to Subversion.

**** Use magit-ediff or 'e' on an unmerged item to resolve merge conflicts with ediff. 
	Resolving Merge Conflicts Hit e on the Unmerged file in magit-status screen to start a 3 way ediff session. For me this is by far the killer feature. This is especially useful since I do a lot of work on teams and the git history is hardly linear. This usually takes all headaches out of the process.
	
    Magit will set up an ediff with three buffers A, B and C. A and B are the original (conflicting) files, and C is the conflicted merge.Use 'n'/'p' to move to the next/previous conflict, use 'a'/'b' to choose which changes (those in a A or B) should be the ones to keep in the merged file.You can always just switch to buffer C and edit what the merged version should look like.Once you're done resolving all conflicts, just hit 'q' to exit the ediff merging session, ediff will prompt you to save the changes to the merged file. Save them and then move on to the next unmerged file.Once you're done, just stage the resolved versions of the files and continue with your merge or rebase.
	After resolving the conflict, back to M-x magit-status and s on the Unmerge line will stage the result. Committing with c c prompts for a commit message prepared with the list of conflicting files and a relevant comment can be added explaining how the conflict was resolved.

**** magit-log (press l then press another l in magit-status), you can interact with every commit:
	RET to view relevant changes of a commit. A window dedicated to that commit is opened inside Emacs, with commit message and hunks. Press n to move to next hunk and p to move to previous hunk. If you want to jump to a hunk, just move point to that hunk and press RET! Magit can even jump to the exact location of the character in the hunk. magit-status is an excellent way to review your commit before pushing changes, because you can use all the editing power of Emacs in the magit-status buffer.
	
	For each hunk, you can press v to revert if you want to undo some change. After pressing v, magit-status is updated immeidately with the reverted changes and you can stage to amend the current commit. To amend, press C-c C-a. An Emacs window is opened for you to compose the commit message; after done composing, press C-c C-c to commit or C-c C-k to cancel. Then, magit-status shows you two commits: one is unpulled commit (the old commit before amending), one is unpushed commit (the new commit after amending). Press P to open magit-push popup: this buffer lists relevant arguments for pushing a commit. Enter -f to force push to override the old commit and finally press P again to push the new commit to override the old one. Well, if you don't like to amend, you can always push a revert commit.
	
	You can also perform interactive rebase with Magit: from magit-log (with beautiful presentation), move point to a commit you want to rebase. Press E on a commit you want to rebase. A buffer appears similar to when you run git rebase -i <commit_hash>that displays the relevant commits, but the buffer is also interactive. Instead of typing the full word "pick" to pick a commit, you can press k to kill a commit (the commit is crossed out), press e to edit a commit, M-p to move commit up and M-n to move commit down etc... there's a short note below specifies these bindings. After that, C-c C-c to start your interactive rebase session. Keep rebasing then press C-c C-a to amend, then move on to the next commit by pressing R: a menu asks for you to [C]ontinue, [A]bort or keep working in the current commit (I forgot they key binding). After you done your rebasing, force push to override the old commits to amend.

**** Magit branch manager is also very interactive. 
	From magit-status press b to open branch popup buffer; it lists arguments relevant to branch command. Then, press v to select a list of branches (or you can execute the stand alone magit-branch-manager) to open the branch manager. You can select branch simply by moving point to a branch then press RET! No more menially typing on the command line and press TAB. To delete a branch, move point to that branch and press k. As you can see, the same key binding has same meaning: kill, but in many different context. Similarly, D stands for Diff.

**** Precision staging I love git add -p but magit takes it to the next level. 
	After using TAB to expand the diff in the Unstaged area, you can use the usual emacs marking (C-SPC) to select what you want to stage! This is brilliant. For me, many times the diff blocks you can cycle through with n and p are too large or I have gone a while without committing and I'm trying to narrow down code to keep the commit germane. Being able to precisely mark a region and stage it is sooo nice. (edit: likewise, at the magit-status screen you can start a region and select all the filenames you specifically want to stage or unstage wholesale ...)

**** tutorial
- http://ergoemacs.org/emacs/emacs_magit-mode_tutorial.html
- http://jr0cket.co.uk/2012/12/driving-git-with-emacs-pure-magic-with.html.html
- http://jr0cket.co.uk/2012/12/driving-git-with-emacs-part-two-may-log.html.html
- http://magit.vc/manual/magit-refcard.pdf

**** key map
   - M-x magit-status switch to the status buffer of that repository 使用这个命令查看Git的状态，在git中的命令为git status
   - s to stage files 把untracked或者unstaged文件的状态改成stage模式，
   - c to commit (type in your commit message then C-c C-c to save the message and commit)  把所有staged文件都commit到索引仓库中
   - P P to do a git push Update remote refs along with associated objects
   - F F to do a git pull Fetch from and merge with another repository or a local branch
   - TAB  Toggle hidden status of current section 用来转换显示当前文件的一些信息
   - i ignore file this will add the filename to the .gitignore file. 忽略当前文件的版本控制，如一些临时文件
   - I ignore file this will add the file to .git/infor/exclude
   - C-h m Magit的使用帮助信息
   
   - TAB             magit-toggle-section
   - RET             magit-visit-item
   - C-w             magit-copy-item-as-kill
   - C-x             Prefix Command
   - ESC             Prefix Command
   - SPC             magit-show-item-or-scroll-up
   - !               magit-key-mode-popup-running
   - $               magit-display-process
   - +               magit-diff-larger-hunks
   - -               magit-diff-smaller-hunks
   - .               magit-mark-item
   - 0               magit-diff-default-hunks
   - 1               magit-show-level-1
   - 2               magit-show-level-2
   - 3               magit-show-level-3
   - 4               magit-show-level-4
   - :               magit-git-command
   - =               magit-diff-with-mark
   - ?               magit-describe-item
   - A               magit-cherry-pick-item
   - B               magit-key-mode-popup-bisecting
   - C               magit-add-log
   - D               magit-diff
   - E               magit-interactive-rebase
   - F               magit-key-mode-popup-pulling
   - G               magit-refresh-all
   - I               magit-ignore-item-locally
   - L               magit-add-change-log-entry-no-option
   - M               magit-key-mode-popup-remoting
   - P               magit-key-mode-popup-pushing
   - R               magit-rebase-step
   - S               magit-stage-all
   - U               magit-unstage-all
   - X               magit-reset-working-tree
   - ^               magit-goto-parent-section
   - a               magit-apply-item
   - b               magit-key-mode-popup-branching
   - c               magit-log-edit
   - d               magit-diff-working-tree
   - e               magit-ediff
   - f               magit-key-mode-popup-fetching
   - g               magit-refresh
   - h               magit-toggle-diff-refine-hunk
   - i               magit-ignore-item
   - k               magit-discard-item
   - l               magit-key-mode-popup-logging
   - m               magit-key-mode-popup-merging
   - n               magit-goto-next-section
   - o               magit-key-mode-popup-submodule
   - p               magit-goto-previous-section
   - q               magit-quit-session
   - r               magit-key-mode-popup-rewriting
   - s               magit-stage-item
   - t               magit-key-mode-popup-tagging
   - u               magit-unstage-item
   - v               magit-revert-item
   - w               magit-wazzup
   - x               magit-reset-head
   - z               magit-key-mode-popup-stashing
   - DEL             magit-show-item-or-scroll-down
**** TODO Unresolved [/]  
- compare two commit files;
- compare two files in different branch.
- compare two version;
**** Resolved  
- stage individual hunks and parts of hunks in a file.
	emacs init must specify: (prefer-coding-system 'utf-8)
*** git-gutter
** TODO ediff
(setq ediff-split-window-function (quote split-window-horizontally))  将其缺省打开模式改为左右：
* DONE max frame when startup
	(custom-set-variables
		'(initial-frame-alist (quote ((fullscreen . maximized)))))

* DONE modeline
** date time
** line, column
** uniquify file name
** which function
** mode
* DONE switch window
M+num
* DONE skip to match parens(forward/backward-sexp)
C-M-left/right
* narrowing
C-x n n (narrow-to-region) C-x n w (widen)
* DONE vlf
** in vlf buffer:
C-c C-v n vlf-next-batch
C-c C-v p vlf-prev-batch
C-c C-v spc vlf-next-batch-from-point
C-c C-v + vlf-change-batch-size
C-c C-v - vlf-change-batch-size
C-c C-v s vlf-re-search-forward
C-c C-v r vlf-re-search-backward
C-c C-v % vlf-query-replace
C-c C-v o vlf-occur
C-c C-v [ vlf-beginning-of-file
C-c C-v ] vlf-end-of-file
C-c C-v j vlf-jump-to-chunk
C-c C-v l vlf-goto-line
C-c C-v e vlf-ediff-buffers
C-c C-v f vlf-toggle-follow
C-c C-v g vlf-revert
** in vlf occur buffer:
RET		vlf-occur-visit
o		vlf-occur-show(cursor still in occur buffer)
ESC		Prefix Command
SPC		scroll-up-command
<		beginning-of-buffer
>		end-of-buffer
?		describe-mode
g		revert-buffer
h		describe-mode
n		vlf-occur-next-match
p		vlf-occur-prev-match
q		quit-window
DEL		scroll-down-command
S-SPC	scroll-down-command
<mouse-1>	vlf-occur-visit
<remap>	Prefix Command
M-RET	vlf-occur-visit-new-buffer
<remap> <save-buffer>			vlf-occur-save
* [ ] switch buffer
** DONE ace jump buffering(C+x b)
** TODO helm-buffers-list(helm-mini)
** DONE C+x <left>/<right>

* DONE jump or back to recent postion (in buffer or between buffers)
(setq rj-ring-length 1000)
(require 'recent-jump)
(recent-jump-mode);;need hook position move functions 
(define-key global-map [f5] 'recent-jump-backward)
(define-key global-map [f6] 'recent-jump-forward)
* DONE browse dir(dired)
C+x d
* DONE highlight symbol(prev or next)
* DONE ace jump
(define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
* DONE shift line up or down
M-up/down : don't use in nw by putty
* DONE line number
* DONE undo redo
(global-set-key (kbd "C-/") 'undo)
(global-set-key (kbd "C-?") 'redo)
* DONE go to last change
http://www.emacswiki.org/emacs/GotoChg
(require 'goto-chg)
(global-set-key (kbd "C-\\") 'goto-last-change)
* DONE undo/redo layout
Navigate window layouts with "C-c <left>" and "C-c <right>"
(global-set-key (kbd "C-x 4 u") 'winner-undo)
(global-set-key (kbd "C-x 4 r") 'winner-redo)
* DONE project(ile)
** DONE grep words in project
C-c p s g(modify init-ignored.el for ignored files or dir)
https://github.com/bbatsov/projectile
*** key(Interactive Commands)
Here's a list of the interactive Emacs Lisp functions, provided by Projectile:
| ;;Keybinding    | Description                                                                                                |
|-----------------+------------------------------------------------------------------------------------------------------------|
| ;;C-c p g       | Display a list of all files at point in the project. With a prefix argument it will clear the cache first. |
| ;;C-c p f       | Display a list of all files in the project. With a prefix argument it will clear the cache first.          |
| ;;C-c p F       | Display a list of all files in all known projects.                                                         |
| ;;C-c p s g     | Run grep on the files in the project.                                                                      |
| ;;M-- C-c p s g | Run grep on projectile-grep-default-files in the project.                                                  |
| ;;C-c p v       | Run vc-dir on the root directory of the project.                                                           |
|                 |                                                                                                            |
|-----------------+------------------------------------------------------------------------------------------------------------|
|                 |                                                                                                            |
| ;;C-c p 4 f     | Jump to a project's file using completion and show it in another window.                                   |
| ;;C-c p 4 g     | Jump to a project's file based on context at point and show it in another window.                          |
| ;;C-c p d       | Display a list of all directories in the project. With a prefix argument it will clear the cache first.    |
| ;;C-c p 4 d     | Switch to a project directory and show it in another window.                                               |
| ;;C-c p 4 a     | Switch between files with the same name but different extensions in other window.                          |
| ;;C-c p T       | Display a list of all test files(specs, features, etc) in the project.                                     |
| ;;C-c p l       | Display a list of all files in a directory (that's not necessarily a project)                              |
| ;;C-c p b       | Display a list of all project buffers currently open.                                                      |
| ;;C-c p 4 b     | Switch to a project buffer and show it in another window.                                                  |
| ;;C-c p 4 C-o   | Display a project buffer in another window without selecting it.                                           |
| ;;C-c p a       | Switch between files with the same name but different extensions.                                          |
| ;;C-c p o       | Runs multi-occur on all project buffers currently open.                                                    |
| ;;C-c p r       | Runs interactive query-replace on all files in the projects.                                               |
| ;;C-c p i       | Invalidates the project cache (if existing).                                                               |
| ;;C-c p R       | Regenerates the projects TAGS file.                                                                        |
| ;;C-c p j       | Find tag in project's TAGS file.                                                                           |
| ;;C-c p k       | Kills all project buffers.                                                                                 |
| ;;C-c p D       | Opens the root of the project in dired.                                                                    |
| ;;C-c p e       | Shows a list of recently visited project files.                                                            |
| ;;C-c p E       | Opens the .dirs-local.el file of the project.                                                              |
| ;;C-c p s s     | Runs ag on the project. Requires the presence of ag.el.                                                    |
| ;;C-c p !       | Runs shell-command in the root directory of the project.                                                   |
| ;;C-c p &       | Runs async-shell-command in the root directory of the project.                                             |
| ;;C-c p c       | Runs a standard compilation command for your type of project.                                              |
| ;;C-c p P       | Runs a standard test command for your type of project.                                                     |
| ;;C-c p t       | Toggle between an implementation file and its test file.                                                   |
| ;;C-c p 4 t     | Jump to implementation or test file in other window.                                                       |
| ;;C-c p z       | Adds the currently visited file to the cache.                                                              |
| ;;C-c p p       | Display a list of known projects you can switch to.                                                        |
| ;;C-c p S       | Save all project buffers.                                                                                  |
| ;;C-c p m       | Run the commander (an interface to run commands with a single key).                                        |
| ;;C-c p ESC     | Switch to the most recently selected Projectile buffer.                                                    |

If you ever forget any of Projectile's keybindings just do a:
C-hc p C-h
You can change the default keymap prefix C-c p like this:

(setq projectile-keymap-prefix (kbd "C-c C-p"))
It is also possible to add additional commands to projectile-command-map referenced by the prefix key in projectile-mode-map. You can even add an alternative prefix for all commands. Here's an example that adds super-p as the extra prefix:

(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
You can also bind the projectile-command-map to any other map you'd like (including the global keymap). Prelude does this for its prelude-mode-map.

For some common commands you might want to take a little shortcut and leverage the fairly unused Super key (by default Command on Mac keyboards and Windows on Win keyboards). Here's something you can add to your Emacs config:

(define-key projectile-mode-map [?\s-d] 'projectile-find-dir)
(define-key projectile-mode-map [?\s-p] 'projectile-switch-project)
(define-key projectile-mode-map [?\s-f] 'projectile-find-file)
(define-key projectile-mode-map [?\s-g] 'projectile-grep)
Note that the Super keybindings are not usable in Windows. Emacs Prelude already adds those extra keybindings.
*** function:
- jump to a file in project
- jump to files at point in project
- jump to a directory in project
- jump to a file in a directory
- jump to a project buffer
- jump to a test in project
- toggle between files with same names but different extensions (e.g. .h <-> .c/.cpp, Gemfile <-> Gemfile.lock)
- toggle between code and its test (e.g. main.service.js <-> main.service.spec.js)
- jump to recently visited files in the project
- switch between projects you have worked on
- kill all project buffers
- replace in project
- multi-occur in project buffers
- grep in project
- regenerate project etags or gtags (requires ggtags).
- visit project in dired
- run make in a project with a single key chord
  
*** Basic setup
(projectile-global-mode)
If you're going to use the default ido completion it's extremely highly recommended that you install the optional 
flx-ido package, which provides a much more powerful alternative to ido's built-in flex matching.

*** Indexing method

Projectile has two modes of operation - one is portable and is implemented in Emacs Lisp(therefore it's native to Emacs and is known as the native indexing method) and the other relies on external commands like find, git, etc to obtain the list of files in a project.

Since the native indexing mode is much slower, by default the second method is used on all operating systems except Windows. To force the use of native indexing in operating systems other than Windows:

(setq projectile-indexing-method 'native)
To force the use of external indexing in Windows:

(setq projectile-indexing-method 'alien)
This can speed up Projectile in Windows significantly. The disadvantage of this method is that it's not well supported on Windows systems. If there's problem, you can always use native indexing mode.

*** Caching

**** Project files

Since indexing a big project is not exactly quick (especially in Emacs Lisp), Projectile supports caching of the project's files. The caching is enabled by default whenever native indexing is enabled.

To enable caching unconditionally use this snippet of code:

(setq projectile-enable-caching t)
At this point you can try out a Projectile command such as C-c p f (M-x projectile-find-file RET).

Running C-u C-c p f will invalidate the cache prior to prompting you for a file to jump to.

Pressing C-c p z will add the currently visited file to the cache for current project. Generally files created outside Emacs will be added to the cache automatically the first time you open them.

The project cache is persistent and will be preserved during Emacs restarts.

You can purge an individual file from the cache with M-x projectile-purge-file-from-cache or an entire directory with M-x projectile-purge-dir-from-cache.

**** File exists cache

Projectile does many file existence checks since that is how it identifies a project root. Normally this is fine, however in some situations the file system speed is much slower than usual and can make emacs "freeze" for extended periods of time when opening files and browsing directories.

The most common example would be interfacing with remote systems using TRAMP/ssh. By default all remote file existence checks are cached

To disable remote file exists cache that use this snippet of code:

(setq projectile-file-exists-remote-cache-expire nil)
To change the remote file exists cache expire to 10 minutes use this snippet of code:

(setq projectile-file-exists-remote-cache-expire (* 10 60))
You can also enable the cache for local file systems, that is normally not needed but possible:

(setq projectile-file-exists-local-cache-expire (* 5 60))

*** Using Projectile everywhere

If you want Projectile to be usable in every directory (even without the presence of project file):

(setq projectile-require-project-root nil)
This might not be a great idea if you start Projectile in your home folder for instance. :-)

*** Switching projects

When running projectile-switch-project (C-c p p) Projectile invokes the command specified in projectile-switch-project-action (by default it is projectile-find-file).

Depending on your personal workflow and habits, you may prefer to alter the value of projectile-switch-project-action:

projectile-find-file

This is the default. With this setting, once you have selected your project via Projectile's completion system (see below), you will remain in the completion system to select a file to visit. projectile-find-file is capable of retrieving files in all sub-projects under the project root, such as Git submodules. Currently, only Git is supported. Support for other VCS will be added in the future.

projectile-find-file-in-known-projects

Similar to projectile-find-file but lists all files in all known projects. Since the total number of files could be huge, it is beneficial to enable caching for subsequent usages.

projectile-find-file-dwim

If point is on a filepath, Projectile first tries to search for that file in project:

If it finds just a file, it switches to that file instantly. This works even if the filename is incomplete, but there's only a single file in the current project that matches the filename at point. For example, if there's only a single file named "projectile/projectile.el" but the current filename is "projectile/proj" (incomplete), projectile-find-file still switches to "projectile/projectile.el" immediately because this is the only filename that matches.

If it finds a list of files, the list is displayed for selecting. A list of files is displayed when a filename appears more than one in the project or the filename at point is a prefix of more than two files in a project. For example, if `projectile-find-file' is executed on a filepath like "projectile/", it lists the content of that directory. If it is executed on a partial filename like "projectile/a", a list of files with character 'a' in that directory is presented.

If it finds nothing, display a list of all files in project for selecting.

projectile-dired

(setq projectile-switch-project-action 'projectile-dired)
With this setting, once you have selected your project, the top-level directory of the project is immediately opened for you in a dired buffer.

projectile-find-dir

(setq projectile-switch-project-action 'projectile-find-dir)
With this setting, once you have selected your project, you will remain in Projectile's completion system to select a sub-directory of your project, and then that sub-directory is opened for you in a dired buffer. If you use this setting, then you will probably also want to set

(setq projectile-find-dir-includes-top-level t)
in order to allow for the occasions where you want to select the top-level directory.

*** Completion Options

**** Ido

By default Projectile uses ido as its completion system. ido is extremely popular and it is built into Emacs.

As already noted above if you're going to use the ido completion it's extremely highly recommended that you install the optional flx-ido package, which provides a much more powerful alternative to ido's built-in flex matching.

**** Basic (Emacs's default)

If you don't like ido and grizzl you can use regular completion:

(setq projectile-completion-system 'default)
You might want to combine default completion with icomplete-mode for optimum results.

**** Custom Completion Function

You can also set projectile-completion-system to a function:

(setq projectile-completion-system 'my-custom-completion-fn)
(setq projectile-completion-system
      (lambda (prompt choices)
        ;; ...
        ))
An example of a custom completion function is this one, which only show the file name (not including path) and if the file selected is not unique, another completion with names relative to project root appears.

**** Regenerate tags

To be able to regenerate a project's tags via projectile-tags-command, you should install and add to the PATH Exuberant Ctags instead of a plain ctags, which ships with Emacs distribution.

*** Ignoring files

If you'd like to instruct Projectile to ignore certain files in a project, when indexing it you can do so in the .projectile file by adding each path to ignore, where the paths all are relative to the root directory and start with a slash. Everything ignored should be preceded with a - sign. Alternatively, not having any prefix at all also means to ignore the directory or file pattern that follows. Here's an example for a typical Rails application:

-/log
-/tmp
-/vendor
-/public/uploads
This would ignore the folders only at the root of the project. Projectile also supports relative pathname ignores:

-tmp
-*.rb
-*.yml
-models
You can also ignore everything except certain subdirectories. This is useful when selecting the directories to keep is easier than selecting the directories to ignore, although you can do both. To select directories to keep, that means everything else will be ignored.

Example:

+/src/foo
+/tests/foo
Keep in mind that you can only include subdirectories, not file patterns.

If both directories to keep and ignore are specified, the directories to keep first apply, restricting what files are considered. The paths and patterns to ignore are then applied to that set.

*** Customizing project root files

You can set the values of projectile-project-root-files, projectile-project-root-files-top-down-recurring, projectile-project-root-files-bottom-up and projectile-project-root-files-functions to customize how project roots are identified.

To customize project root files settings:

M-x customize-group RET projectile RET

*** File-local project root definitions

If you want to override the projectile project root for a specific file, you can set the file-local variable projectile-project-root. This can be useful if you have files within one project that are related to a different project (for instance, Org files in one git repo that correspond to other projects).

*** Storing project settings

From project to project some things may differ even in same language - different coding styles, separate auto-completion sources, etc. If you need to set some variables according to selected project, you can use standard Emacs feature called Per-Directory Local Variables. To use it you must create file named .dir-locals.el inside project directory. This file must contain something like this:

((nil . ((secret-ftp-password . "secret")
         (compile-command . "make target-x")
         (eval . (progn
                   (defun my-project-specific-function ()
                     ;; ...
                     ))))
 (c-mode . (c-file-style . "BSD")))
The top-level alist member referenced with the key nil applies to the entire project. A key with the name eval will evaluate its arguments. In the example above, this is used to create a function. It could also be used to e.g. add such a function to a key map.

You can also quickly visit the the .dir-locals.el file with C-c p E (M-x projectile-edit-dir-locals RET).

Here are a few examples of how to use this feature with Projectile.

*** Configuring Projectile's Behavior

Projectile offers many customizable variables (via defcustom) that allows us to customize its behavior. Because of how dir-locals.el works, it can be used to set these customizations on a per-project basis.

You could enable caching for a project in this way:

((nil . ((projectile-enable-caching . t))))
If one of your projects had a file that you wanted Projectile to ignore, you would customize Projectile by:

((nil . ((projectile-globally-ignored-files . '("MyBinaryFile")))))
If you wanted to wrap the git command that Projectile uses to find list the files in you repository, you could do:

((nil . ((projectile-git-command . "/path/to/other/git ls-files -zco --exclude-standard"))))
If you want to use a different project name than how Projectile named your project, you could customize it with the following:

((nil . ((projectile-project-name . "your-project-name-here"))))

*** Configure a Project's Compilation, Test and Run commands

There are a few variables that are intended to be customized via .dir-locals.el.

for compilation - projectile-project-compilation-cmd
for testing - projectile-project-test-cmd
for running - projectile-project-run-cmd
They're all set to nil by default, but by setting them you'll override the default commands per each supported project type. These variables can be strings to run external commands or Emacs Lisp functions:

(setq projectile-test-cmd #'custom-test-function)

*** Idle Timer

Projectile can be configured to run the hook projectile-idle-timer-hook every time Emacs is in a project and has been idle for projectile-idle-timer-seconds seconds (default is 30 seconds). To enable this feature, run:

M-x customize-group RET projectile RET
and set projectile-enable-idle-timer to non-nil. By default, projectile-idle-timer-hook runs projectile-regenerate-tags. Add additional functions to the hook using add-hook:

(add-hook 'projectile-idle-timer-hook 'my-projectile-idle-timer-function)

*** Mode line indicator

By default the minor mode indicator of Projectile appears in the form " Projectile[ProjectName]". This is configurable via the custom variable projectile-mode-line, which expects a sexp like '(:eval (format " Proj[%s]" (projectile-project-name))).

The project name will not appear by default when editing remote files (via TRAMP), as recalculating the project name (this is done on every keystroke) is a fairly slow operation there.

*** Extensions

There are a number of packages that built on top of the basic functionality provided by Projectile:

helm-projectile provides Helm integration
persp-projectile provides perspective.el integration
projectile-rails provides extra functionality for Ruby on Rails projects

*** Caveats
Some operations like search (grep) depend (presently) on external utilities such as find.

http://iqbalansari.github.io/blog/2014/02/22/switching-repositories-with-magit/
* DONE change font size
  (global-set-key (kbd "C-=") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
* DONE theme, stripe
* DONE session
* DONE server mode
win7 shortcut menu regedit:
HKEY_CLASSES_ROOT\*\shell\Edit with Emacs\command
default value: "path\to\emacsclientw.exe" --no-wait --alternate-editor="path\to\runemacs.exe" "%1"
* DONE open recent files
(global-set-key "\C-x\ \C-r" 'recentf-open-files)
* DONE rotate buffer
M-x rotate-windows
* DONE covert code between dos and unit
;convert a buffer from dos ^M end of lines to unix end of lines
dos2unix
;vice versa
unix2dos
* DONE rectangle block矩形块操作
C-x r k cut 
C-x r y paste  
C-x r o insert rectangle block  
C-x r c clear  
C-x r t insert text
* DONE helm
** DONE key
| Key Binding | Command                         | Description                                                                                       |
| M-x         | helm-M-x                        | List commands                                                                                     |
| C-c i       | helm-imenu                      | list function                                                                                     |
| C-c h i     | helm-semantic-or-imenu          | Helm interface to semantic/imenu                                                                  |
| M-y         | helm-show-kill-ring             | Shows the content of the kill ring                                                                |
| C-x b       | helm-mini                       | Shows open buffers, recently opened files                                                         |
| C-c h o     | helm-occur                      | Similar to occur                                                                                  |
| C-x C-f/C-o | helm-find-files                 | The helm version for find-file, same as ffap                                                      |
| C-z/C-j/TAB | persistent action               | expand the name when helm-find-files                                                              |
| C-s         | helm-ff-run-grep                | Run grep from within helm-find-files                                                              |
| C-'         | ace-jump-helm-line              |                                                                                                   |
| M-i         | helm-swoop                      | When doing isearch, hand the word over to helm-swoop.(or:From helm-swoop to helm-multi-swoop-all) |
| M-I         | helm-swoop-back-to-last-point   |                                                                                                   |
| C-r         | helm-previous-line              | in swoop                                                                                          |
| C-s         | helm-next-line                  | in swoop                                                                                          |
| C-x <n>     |                                 | jumps to before the hightlighted line.                                                            |
| C-c <n>     |                                 | jumps to after the highlighted line.                                                              |
|             |                                 |                                                                                                   |
|-------------+---------------------------------+---------------------------------------------------------------------------------------------------|
|             |                                 |                                                                                                   |
| C-c h m     | helm-man-woman                  | Jump to any man entry                                                                             |
| C-c h /     | helm-find                       | Helm interface to find                                                                            |
| C-c h l     | helm-locate                     | Helm interface to locate                                                                          |
| C-c h a     | helm-apropos                    | Describes commands, functions, variables,                                                         |
| C-c h h g   | helm-info-gnus                  |                                                                                                   |
| C-c h h i   | helm-info-at-point              |                                                                                                   |
| C-c h h r   | helm-info-emacs                 |                                                                                                   |
| C-c h <tab> | helm-lisp-completion-at-point   | Provides a list of available functions                                                            |
| C-c h b     | helm-resume                     | Resumes a previous helm session                                                                   |
| C-h SPC     | helm-all-mark-rings             | Views content of local and global mark rings                                                      |
| C-c h r     | helm-regex                      | Visualizes regex matches                                                                          |
| C-c h x     | helm-register                   | Shows content of registers                                                                        |
| C-c h t     | helm-top                        | Helm interface to top                                                                             |
| C-c h s     | helm-surfraw                    | Command line interface to many web search engines                                                 |
| C-c h g     | helm-google-suggest             | Interactively enter search terms and get results from Google in helm buffer                       |
| C-c h c     | helm-color                      | Lists all available faces                                                                         |
| C-c h M-:   | helm-eval-expression-with-eldoc | Get instant results for emacs lisp expressions in the helm buffer                                 |
| C-c h C-,   | helm-calcul-expression          | Helm interface to calc                                                                            |
| C-c C-l     | helm-eshell-history             | Interface to eshell history                                                                       |
| C-c C-l     | helm-comint-input-ring          | Interface to shell history                                                                        |
| C-c C-l     | helm-mini-buffer-history        | Interface to mini-buffer history                                                                  |
grep in buffer:
helm-buffers-list, but it's almost the same as helm-mini. The only difference is that helm-buffers-list uses ido-virtual-buffers for listing recently used files, 
while helm-mini uses recentf.
All the C buffers are selected using the pattern *C. In the demo, I also select Tcl buffers with *Tcl and then switched back to C buffers with *C.
I only want to have buffers that contains only the string crash. To do that, I add a space, then add the pattern @crash. After the initial search pattern,
 I hand over the current highlighting buffer to helm-moccur (moccur with Helm interface) using C-s. Candidates can be filtered gradually by adding more pattern, i.e.
 I added memory to filtered down to buffers that contain the string "memory" among the buffers that are containing crash. 
You can also mark multiple with C-SPC or mark all buffers with M-a to search all listing buffers in helm-mini.
As you can see, as you filtered out, the number of candidates decreases, as displayed in the modeline.
At the end, there were 12 buffers remained as the result of filtering, down from the total 253 buffers.
** DONE persistent action
;; For find-file etc.
(define-key helm-read-file-map (kbd "TAB") 'helm-execute-persistent-action)
;; For helm-find-files etc.
(define-key helm-find-files-map (kbd "TAB") 'helm-execute-persistent-action)

persistent-action means execute an action without quitting helm-session.
If the source have no defined persistent-action defined, the first
action is executed instead.

The main persistent action is bound to C-z, however many sources have
other persistent actions bound to differents keys.

For `helm-find-files', on a regular file, first hit on C-z expand the
file name, second hit open the file and display buffer in the other
window and third hit kill the buffer (unless it was already open before
starting helm session).
While in `helm-find-files' session hit C-c ? for more infos
** DONE ace-jump-helm-line
(global-set-key (kbd "C-'") 'ace-jump-helm-line)
** DONE helm-occur(moccur)
(global-set-key (kbd "C-c h o") 'helm-occur)
** DONE helm-browse-killring
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
** DONE helm-swoop
*** key
(require 'helm-swoop)
(global-set-key (kbd "M-i") 'helm-swoop)
(global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
(global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)

;; When doing isearch, hand the word over to helm-swoop
(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
;; From helm-swoop to helm-multi-swoop-all
(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

;; Move up and down like isearch
(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
(define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
(define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

*** Feature
Culling all lines in buffer with your input
Highlight multiple matched pattern
Jumping line to line according to list buffer's move
Cache result until modifies the buffer
Go back to the last line
Multi separated line culling
Culling lines are editable
*** Usage
Now helm-swoop has several ways:

M-x helm-swoop when region active
M-x helm-swoop when the cursor is at any symbol
M-x helm-swoop when the cursor is not at any symbol
M-3 M-x helm-swoop or C-u 5 M-x helm-swoop multi separated line culling
M-x helm-multi-swoop multi-occur like feature
M-x helm-multi-swoop-all apply all buffers
C-u M-x helm-multi-swoop apply last selected buffers from the second time
M-x helm-multi-swoop-org apply to all org-mode buffers
M-x helm-multi-swoop-current-mode apply to all buffers with the same major-mode as the current buffer
M-x helm-swoop-same-face-at-point list lines have the same face at the cursor is on
During isearch M-i to hand the word over to helm-swoop
During helm-swoop M-i to hand the word over to helm-multi-swoop-all
While doing helm-swoop press C-c C-e to edit mode, apply changes to original buffer by C-x C-s
It's able to use words within a region or a word at symbol as search query when it called. Also use a keybind you set just type like M-i instead of M-x helm-swoop.

*** Edit mode
While doing helm-swoop type C-c C-e to enter the edit mode. Before enter the edit mode, you can choose some lines marked by C-SPC or M-SPC or M-a to edit. Apply changes to original buffer type C-x C-s.

*** Across multiple buffers

M-x helm-multi-swoop

Select any buffers by [C-SPC] or [M-SPC]
Press [RET] to start helm-multi-swoop
helm-multi-swoop

M-x helm-multi-swoop-all
Skip select phase and apply all buffers.

C-u M-x helm-multi-swoop
Skip select phase and apply last selected buffers, if you have done helm-multi-swoop before.

M-x helm-multi-swoop-org
Skip the select phase and apply to all org-mode buffers

M-x helm-multi-swoop-current-mode
Skip the select phase and apply to all buffers with the same major mode as the current buffer

*** Multiline behavior
M-4 M-x helm-swoop or C-u 4 M-x helm-swoop
** DONE linum-relative
(helm-linum-relative-mode 1)  enables linum-relative in helm. 
Helm buffers then display nine numbered candidates before an after the current selection (highlighted line).
C-x <n>  jumps to before, and  C-c <n>  jumps to after the highlighted line.
** DONE helm-projectile
*** key
| Key Binding | Command                                     | Description                                                  |
| C-c p h     | helm-projectile                             | Helm interface to projectile                                 |
|             | helm-projectile-switch-to-buffer            |                                                              |
|             | helm-projectile-find-file                   |                                                              |
|             | helm-projectile-switch-project              |                                                              |
| C-c p g     | helm-projectile-find-file-dwim              | Find file based on context at point                          |
|             |                                             |                                                              |
|-------------+---------------------------------------------+--------------------------------------------------------------|
| C-c p p     | helm-projectile-switch-project              | Switches to another projectile project                       |
| C-c p f     | helm-projectile-find-file                   | Lists all files in a project                                 |
| C-c p F     | helm-projectile-find-file-in-known-projects | Find file in all known projects                              |
| C-c p d     | helm-projectile-find-dir                    | Lists available directories in current project               |
| C-c p e     | helm-projectile-recentf                     | Lists recently opened files in current project               |
| C-c p a     | helm-projectile-find-other-file             | Switch between files with same name but different extensions |
| C-c p i     | projectile-invalidate-cache                 | Invalidate cache                                             |
| C-c p z     | projectile-cache-current-file               | Add the file of current selected buffer to cache             |
| C-c p b     | helm-projectile-switch-to-buffer            | List all open buffers in current project                     |
| C-c p s g   | helm-projectile-grep                        | Searches for symbol starting from project root               |
| C-c p s a   | helm-projectile-ack                         | Same as above but using ack                                  |
| C-c p s s   | helm-projectile-ag                          | Same as above but using ag                                   |
** CANCELED helm-ls-git
** BUG helm-gtags
find tags is not accurate than native gtags. helm-gtags-pop-stack cann't work.
* DONE ace-isearch
(global-set-key (kbd "M-s") 'isearch-forward)
(global-set-key (kbd "M-r") 'isearch-backward)
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(define-key isearch-mode-map (kbd "C-'") 'ace-isearch-jump-during-isearch)
* DONE isearch
search symbol at current point: C-s C-w / C- r C-w
* DONE ggtags
** Preparation
run gtags at root directory of source code.
** key
- "M-." ggtags-find-tag-dwim  to find the tag at point.
- "M-]" ggtags-find-reference
- "C-M-." ggtags-find-tag-regexp
- "M-," find next same name symbol
- "M-*" go to last postion(press M-. place)
When a search finds multiple matches, a buffer named *ggtags-global* is popped up and 
ggtags-navigation-mode is turned on to facilitate locating the right match. 
ggtags-navigation-mode makes a few commands in the *ggtags-global* buffer globally accessible:
- M-n Move to the next match.
- M-p Move to the previous match.
- M-} Move to next file.
- M-{ Move to previous file.
- M-= Move to the file where navigation session starts.
- M-< Move to the first match.
- M-> Move to the last match.
- C-M-s or M-s s Use isearch to find the match.
- RET Found the right match so exit navigation mode. Resumable by M-, (tags-loop-continue).
- M-* Abort and go back to the location where the search was started.
** find tag
M-.
** jump back
M-*
** find refrence
M-]
* DONE find file(ffap)
|               | ffap           | find file      |
|---------------+----------------+----------------|
| in projectile | C-c p g        | C-c p h        |
| no projectile | M-x ffap       | helm-find-file |
|               | helm-find-file |                |
* DONE visual-line-mode
(setq global-visual-line-mode t)
* DONE parentheses
** DONE hightlighting parentheses
(show-paren-mode t)
** DONE match
smartparens
* DONE moccur
same as helm-swoop, so i do not use it.
* DONE plugin(package) manager, update plugin
M-x package-refresh-contents RET
M-x package-install RET xxx RET
M-x package-list-packages RET
* DONE autocomplete
* DONE list
** DONE file
helm-projectile C-c p h
** DONE function
C-c i
* DONE emacs-zoom-window
(global-set-key (kbd "C-x C-z") 'zoom-window-zoom)
* ediff
Ediff 比较的项目有：( 可用 M-x 来启动 )
| 比较项目                                       | 说明                                                                                                                       |
| ediff-regions-linewise, ediff-regions-         | 询问两个缓冲区的名字，然后比较相应的区域。不过你只能在每一个缓冲区中选定一个区域，                                         |
|                                                | 而不能比较一个文件缓冲区的两个区域。                                                                                       |
| ediff-buffers                                  | 询问两个缓冲区的名字，然后比较                                                                                             |
| ediff-files                                    | 询问两个文件的名字，加载之，然后比较                                                                                       |
| ediff-windows-linewise, ediff-windows-wordwise | 让你选两个窗口，然后比较窗口的内容。 -linewise- 函数比 -wordwise- 函数要快，                                               |
|                                                | 但另一方面， -wordwise- 工作方式更好，尤其是小区域作业时。 -linewise- 一行一行地比较， -wordwise- 一个单词一个单词地比较。 |
一些Ediff 控制命令
在 control buffer 中，按键。
| 快捷键         | 命令                              | 说明                                                                 |
| q              | ediff-quit                        | 关闭 ediff control buffer， 并退出 ediff                             |
| Space 或 n     | ediff-next-difference             | 下一个差异处                                                         |
| Del 或 p       | ediff-previous-difference         | 上一个差异处                                                         |
| [n]j           | ediff-jump-to-difference          | 有数字前缀 [n] 修饰，第n个差异处,n可为负数                           |
| v 或 C-v       | ediff-scroll-vertically           | 所有缓冲区同步向下滚动                                               |
| V 或 M-v       | ediff-scroll-vertically           | 所有缓冲区同步向上滚动                                               |
| <              | ediff-scroll-horizontally         | 所有缓冲区同步向左滚动                                               |
| >              | ediff-scroll-horizontally         | 所有缓冲区同步向右滚动                                               |
| (vertical bar) | ediff-toggle-split                | 切换缓冲区布局方式, 水平和竖直                                       |
| m              | ediff-toggle-wide-display         | 在正常 frame 大小和最大化之间切换                                    |
| a              | ediff-copy-A-to-B                 | 把Buffer-A的内容复制到Buffer-B                                       |
| b              | ediff-copy-B-to-A                 | 把Buffer-B的内容复制到Buffer-A                                       |
| r a 或 r b     | ediff-restore-diff                | 恢复 Buffer-A 或 Buffer-B 差异区域中的被修改的内容                   |
| A 或 B         | ediff-toggle-read-only            | 切换 Buffer-A 或 Buffer-B 的只读状态                                 |
| g a 或 g b     | ediff-jump-to-difference-at-point | 根据光标在缓冲区中的位置，设置一个离它们最近的差异区域为当前活动区域 |
| C-l            | ediff-recenter                    | 恢复先前的所有缓冲区比较的高亮差异区。                               |
| !              | ediff-update-diffs                | 重新比较并高亮差异区域                                               |
| w a 或 w b     | ediff-save-buffer                 | 保存 Buffer-A 或 Buffer-B 到磁盘                                     |
| E              | ediff-documentation               | 打开 Ediff 文档                                                      |
| z              | ediff-suspend                     | 关闭 ediff control buffer, 只是挂起，可在以后恢复 ediff 状态         |
比较三个文件
此种需要大都发生在两个文件共有一个原始的文件。假设 C —> A, C —> B. A与B可能都对C进行了修改，你需要知晓，究竟A和B哪个对C做了什么修改。此时就需要比较三个文件了。
假如A有一部分内容，而在B中不存在，可能是下列两种情况之一：
- A 中增添了这部分内容
- B 中删除了这部分内容
你就应该比较A B C 三个文件来确定究竟是哪种情况。
操作
有两个函数
| 函数           | 说明           |
| ediff-files3   | 比较三个文件   |
| ediff-buffers3 | 比较三个缓冲区 |
具体操作
比较两个文件或缓冲区的所有操作，几乎都适于三个比较。不过在进行缓冲区差异区从A到B拷贝的操作略有不同：
| 快捷键 | 说明                        |
| cb     | 将 Buffer-C 拷贝到 Buffer-A |
| ab     | 将 Buffer-A 拷贝到 Buffer-B |
以此类推，在 Buffer-A , Buffer-B, Buffer-C之间的操作可以很容易猜出。
Ediff Session
你可能同时要比较好多对文件，你可以同时拥有多个 Ediff Session 。按 z 挂起当前 Ediff session ,然后启动另一个 Ediff session 就可以了。 此时，在 control buffer 中按 R 或是按下 M-x eregistry, 将会打开一个 *Ediff Registry* 的缓冲区，此缓冲区包含当前运行的所有 Ediff Sessions.可以选择一个 Ediff session 来进入。
合并文件
比较文件目录
与版本控制系统(VC) 一块儿工作
* eval-last-sexp
C-x C-e
* map key in init-key.el
* cua, shift key for select.
https://www.zhihu.com/question/27478438/answer/59796810
(defun cua-or-multicursor ()
  (interactive)
  (if (use-region-p)
      (mc/edit-lines)
    (cua-rectangle-mark-mode)))
;; http://emacs.stackexchange.com/a/9916/514
(eval-after-load "multiple-cursors-core"
  (lambda ()
     (add-to-list 'mc--default-cmds-to-run-once 'cua-or-multicursor)))
* CANCELED flymake
* CANCELED tramp
* language mode
** c/c++
** txt
** org
* w3m open link
* speedbar
* dictionary
* CANCELED ido(disable), smex
** find file
** grep content
** switch
* TODO org
** TODO 1 配置
把下面几行加到 .emacs 文件里。后三行是为命令定义全局快捷键――请改成适合你自己的。
#+BEGIN_EXAMPLE
;; The following lines are always needed. Choose your own keys.
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
(add-hook 'org-mode-hook 'turn-on-font-lock) ; not needed when global-font-lock-mode is on
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
#+END_EXAMPLE
设置之后，打开 .org 扩展的文件会自动进入 org 模式。

** 2 大纲
2.3 视图循环
大纲模式可以隐藏缓冲区里的部分正文。Org 用绑定到 TAB 和 S-TAB 上的两个全命令来改变视图。

| TAB             | 子树循环：当加上一个前缀参数时（C-u TAB），在下面的状态中改变当前子树的视图 |
|                 | FOLDED->CHILDREN->SUBTREE                                                   |
|                 | 当加上shift键时会触发全局的视图循环。                                       |
| S-TAB和C-u TAB  | 全局循环：使整个缓冲区在下列状态中循环                                      |
|                 | OVERVIEW->CONTENTS->SHOWALL                                                 |
| C-u C-u C-u TAB | 显示全部，包括drawers。                                                     | 
  
当 Emacs 刚打开文件时，全局的状态是 OVERVIEW，也即只有顶层的标题可见。这可以通过变量 org-startup-folded 来设置。
也可以通过 startup 关键字设置只对单个文件有效：
#+BEGIN_EXAMPLE
#+STARTUP: content
#+END_EXAMPLE

*** 折叠大纲

| 快捷键 | 命令         | 说明                                                               |
|--------+--------------+--------------------------------------------------------------------|
| S-TAB  | org-shifttab | 循环切换整个文档的大纲状态（三种状态：折叠，打开下一级，打开全部） |
|--------+--------------+--------------------------------------------------------------------|
| TAB    | org-cycle    | 循环切换光标所在大纲的状态                                         |

*** 在大纲之间移动

| 快捷键    | 命令 | 说明                        |
|-----------+------+-----------------------------|
| C-c C-n/p |      | 下/上一标题                 |
|-----------+------+-----------------------------|
| C-c C-f/b |      | 下/上一标题（仅限同级标题） |
|-----------+------+-----------------------------|
| C-c C-u   |      | 跳到上一级标题              |
|-----------+------+-----------------------------|
| C-c C-j   |      | 切换到大纲浏览状态          |

*** 基于大纲的编辑

| 快捷键                | 命令 | 说明                                                       |
|-----------------------+------+------------------------------------------------------------|
| M-RET                 |      | 插入一个同级标题                                           |
| M-S-RET               |      | 插入一个同级TODO 标题                                      |
| M-LEFT/RIGHT          |      | 将当前标题升/降级                                          |
| M-S-LEFT/RIGHT        |      | 将子树升/降级                                              |
| M-S-UP/DOWN           |      | 将子树上/下移                                              |
| C-c *                 |      | 将本行设为标题/正文                                        |
| C-c C-w               |      | 将子树或区域移动到另一标题处（跨缓冲区）                   |
| C-x n s/w             |      | 只显示当前子树/返回                                        |
| C-c C-x b             |      | 在新缓冲区显示当前分支（类似C-x n s)                       |
| C-c /                 |      | 只列出包含搜索结果的大纲，并高亮，支持多种搜索方式         |
| C-c C-c               |      | 取消高亮                                                   |
|-----------------------+------+------------------------------------------------------------|
| TAB（新的空的条目中） |      | 	如果新的条目中还没有文字，TAB 会调整到合适的级别。 |

** 3 文本列表
在大纲树的一项中，自定义格式的列表可以提供更多的组织结构，也使我们可以得到一个复先框列表（见 5.6 节［复先框］）。Org 模式可以处理这种列表，并且 HTML 导出器（见12章）也支持这种格式。

Org 能够识别有序列表、无序列表和描述列表。

无序列表项以‘-’、‘+’或者‘*‘开头。
有序列表项以‘1.’、‘1)’或者开头。
描述列表用‘::’将项和描述分开。
同一列表中的项的第一行必须缩进相同程度。当下一行的缩进与列表项的的开头的符号或者数字相同或者更小时，这一项就结束了。当所有的项都关上时，或者后面有两个空行时，列表就结束了。

当光标位于一项的第一行时（带有项标志符号的行），下面的命令将会作用于该项：

| TAB            | 折叠项                                                                                               |
| M-RET          | 在当前级别插入一个项，有前缀时是强制新建一个标题                                                     |
| M-S-RET        | 插入一个带有复先框的项（见 2.5 节［复先框］）                                                        |
| M-S-UP/DOWN    | 将当前项和它的子项向上/下移动（和相同的缩进的前/后一个项交换位置）。如果列表是有序的，数字会自动改变 |
| M-LEFT/M-RIGHT | 提升/降低项的缩进，不包含子项                                                                        |
| M-S-LEFT/RIGHT | 提升/降低项的缩进，包含子项                                                                          |
| C-c C-c        | 如果项中有复先框，就触发改变其状态。并且自动保持本项的符号与缩进在列表中的一致性                     |
| C-c -          | 循环改变将当前列表的项标志符号                                                                       |

** 4 表格
任何以‘|’为首个非空字符的行都会被认为是表格的一部分。’|‘也是列分隔符。
当你在表格内部输入 TAB、RET 或者 C-c C-c 时表格都会自动调整。TAB 会进入下一个区域（RET 进入下一行）并且创建一个新的行。
当按 TAB、S-TAB 或者 RET 将光标移动到其他区域时，区域中会自动填充一些空格。
表格的缩进程度可以在第一行设定。以’|-’开头的一行会作为一个水平分隔行，当它下次调整排列时会将‘-’扩展至填充整行。

*** 创建和转换表格

| 快捷键   | 命令 | 说明             |
|----------+------+------------------|
| C-c 竖线 |      | 创建或转换成表格 |

*** 调整和区域移动  

| 快捷键  | 命令 | 说明                           |
|---------+------+--------------------------------|
| C-c C-c |      | 调整表格，不移动光标           |
| TAB     |      | 移动到下一区域，必要时新建一行 |
| S-TAB   |      | 移动到上一区域                 |
| RET     |      | 移动到下一行，必要时新建一行   |

*** 编辑行和列

| 快捷键         | 命令 | 说明                             |
|----------------+------+----------------------------------|
| M-LEFT/RIGHT   |      | 移动列                           |
| M-UP/DOWN      |      | 移动行                           |
| M-S-LEFT/RIGHT |      | 删除/插入列                      |
| M-S-UP/DOWN    |      | 删除/插入行                      |
| C-c -          |      | 添加水平分割线                   |
| C-c RET        |      | 添加水平分割线并跳到下一行       |
| C-c ^          |      | 根据当前列排序，可以选择排序方式 |

** 5 待办事项
Org 模式并不用一个单独的文件来维持TODO列表。它是一些笔记的集合体，因为TODO列表是在你记录笔记的过程中逐渐形成的。
你Org模式下可以很容易地将树中的一项标记为一个TODO的项。用这种方式，信息内容不会冗余加倍，而且可以显示TODO项的上下文环境。
当然，这种处理待办事项的方式会将它们分散于各个笔记文件中。Org 模式提供了一些方法使我们可以把它们看作一个整体来处理。

*** 使用TODO状态
当标题以 TODO 开关时它就成为了一个 TODO 项，下面是一些使用 TODO 项的常用命令：

| C-c C-t      | 	将当前项的状态在（unmarked）->TODO->DONE 之间循环切换，同样的切换也可以在时间轴（timeline） 和议程（ agenda） 的缓冲区（buffer）中用 t 键“远程”进行 |   |
| S-RIGHT/LEFT | 	选择下一个/上一个 TODO 状态，与上面的循环方式相同。                                                                                                   |   |
| C-c / t      | 	在稀疏树中显示 TODO 项。将 buffer 折叠，但是会显示 TODO 项和它们所在的层次的标题。                                                                    |   |
| C-c a t      | 	显示全局 TODO 列表。从所有的议程文件中收集 TODO 项到一个缓冲区中。详见 10.3.2 节。                                                                    |   |
| S-M-RET      | 	在当前项下插入一个新的 TODO 项。                                                                                                                      |   |
|              |                                                                                                                                                               |   |
改变 TODO 的状态会触发标签改变。查看选项 org-todo-state-tags-triggers 的描述获得更多信息。

*** 多状态工作流程
你可以用 TODO 关键字来定义不同的状态，用以处理项，比如：
(setq org-todo-keywords
      '((sequence "TODO" "FEEDBACK" "VERIFY" "|" "DONE" "DELEGATED")))
竖直线将 TODO 关键字（还需要进一步的动作）和 DONE 状态（不需要进一步的动作）分隔开。如果你不给出竖直线，
最后一个状态会作为 DONE 状态。设置之后，C-c C-t 就会将状态从 TODO 转换到 FEEDBACK，再转换到 VERIFY，最后到 DONE 和 DELEGATED。

有时你可能希望同时使用几个不同的 TODO 状态集合。例如，你可能想要一个基本的 TODO/DONE，以及一个修改 bug 的工作流程和
一个隔开的状态来表示取消的项目（既还是 DONE，也不需要进一步的动作），你可以这样设置：
#+BEGIN_EXAMPLE
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
        (sequence "|" "CANCELED(c)")))
#+END_EXAMPLE
关键字应该各不相同，这样对于一个选项 Org 才知道该用哪个状态序列（集合）。例子中也给出了快速使用一个关键字的方法，
就是在关键字后面括号中给出快捷字母——当用 C-c C-t时，会询问，让你输入一个字母。

要定义只在一个文件中有效的 TODO 关键字，可以在文件中任意地方给出下面的文本：
#+BEGIN_EXAMPLE
#+TODO: TODO(t) | DONE(d)
#+TODO: REPORT(r) BUG(b) KNOWNCAUSE(k) | FIXED(f)
#+TODO: | CANCELED(c)
#+END_EXAMPLE

当改变这些行中的一行后，光标停留在改变行上，用 C-c C-c 让改变生效。

*** 进度日志
当你改变一个 TODO 状态为 DONE 时，或者当你每次改变一个 TODO 项的状态时，Org 都会自动记录时间戳或者作一个记录。这是高度可配置的。
可以基于每一个关键字进入设置，并且可以定位到一个文件甚至子树。

**** 完成的项目

最基本的日志功能是跟踪一个特定项目的完成。这可以这样实现：
(setq org-log-done 'time)
这时当你将一个项目从一个 TODO（未完成）状态改变为一个完成状态时，标题下面就会插入一行 “CLOSED:[timestamp]”。
如果你想和时间戳一起作一个记录，用：
(setq org-log-done 'note)
这时会提示你输入一个记录（note），并将它保存在标题为“Closing Note”项目之下。

**** 跟踪TODO状态变化

你可能想跟踪 TODO 状态的变化。可以只记录一个时间戳，也可以为变化作一个带时间戳的记录。记录会被插入到标题之后形成列表。
当有很多记录之后，你可能希望将记录取出放到抽屉里。通过定制变量 org-log-into-drawer 可以实现这个功能。 
对于状态记录，Org 可以实现基于每个状态关键字的设置。实现方法是在每个后的括号中指定“！”（记录时间戳）或“@”（作一个记录）。例如：
#+BEGIN_EXAMPLE
#+TODO: TODO(t) WAIT(w@/!) | DONE(d!) CANCELED(c@)
#+END_EXAMPLE
将会设置 TODO 关键字和快速访问字母，以及当一个项目设为 DONE 时，会记录时间戳，当状态变为 WAIT 或 CANCELED 时，会作一个记录。
这个语法也适用于变量 org-todo-keywords。

*** 优先级
如果你广泛地使用 Org 模式，这样你就会有大量的 TODO 项。给它们设定优先级就很有必要。可以在 TODO 项的标题中加入一些标记（cookie）来设置它们的优先级，像这样：

Org模式支持三个优先级别：’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的。优先级只在议程中有用。

| C-c ,  | 设置当前标题的优先级。按^^^选择一个级别，或者SPC删除标记（cookie）。 |
| S-UP   |                                                                      |
| S-Down | 增加/减少当前标题的优先级。                                          | 
  
*** 任务细分
很多时候将一个大的任务分成几个的易于完成的小任务是明智的。你可以通过在TODO项目下新建一个大纲树，并在子树上标记子任务来实现这个功能。
为了能对已经完成的任务有个大致的了解，你可以在标题的任何地方插入‘[/]’或者‘[%]’。当每个子任务的状态变化时，或者当你在标记上按 C-c C-c时，这些标记状态也会随之更新。例如：

#+BEGIN_EXAMPLE
 * Organize Party [33%]
 ** TODO Call people [1/2]
 *** TODO Peter
 *** DONE Sarah
 ** TODO Buy food
 ** DONE Talk to neighbor
 #+END_EXAMPLE

*** 复选框
当纯文本中的项以‘[]’开头时，就会变成一个复选框。复选框不会包含在全局 TODO 列表中，所以它们很适合地将一个任务划分成几个简单的步骤。下面是一个复选框的例子：

#+BEGIN_EXAMPLE
 * TODO Organize party [1/3]
  - [-] call people [1/2]
    - [ ] Peter
    - [X] Sarah
  - [X] order food
  - [ ] think about what music to play
#+END_EXAMPLE

复选框是分层工作的。所以如果一个复选框项目如果还有子复选框，触发子复选框将会使该复选框变化以反映出一个、多个还是没有子复选框被选中。

下面是处理复选框的命令：

| C-c C-c | 	触发复选框的状态或者（加上前缀）触发复选框的的存在状态。       |
| M-S-RET | 	增加一个带有复选框的项。这只在光标处于纯文本列表项中才起使用。 |

** 6 标签
要为交叉相关的信息提供标签和上下文，一个不错的方法是给标题分配标签。Org 模式能够广泛地支持标签。
每一个标题都能包含多个标签，它们位于标题的后面。标签可以包含字母，数字， ‘_’ 和 ‘@’ 。
标签的前面和后面都应该有一个冒号，例如，“:work:”。可以指定多个标签，就像“:work:urgent:”。
标签默认是粗体，并和标题具有相同的颜色。

*** 6.1 标签继承
标签具有大纲树的继承结构。如果一个标题具有某个标签，它的所有子标题也会继承这个标签。例如，在列表

#+BEGIN_EXAMPLE
 * Meeting with the French group     :work:
 ** Summary by Frank                 :boss:notes:
 *** TODO Prepare slides for him     :action:
#+END_EXAMPLE

中,尽管没有明确标出,最后一个标题会有标签“:work:”，“:boss:”，“:note:”，和“:action”。
你也可以设定一个标签让所有的标题都继承，就好像标签在包含整个文件的第零级标题中指定了一样。用下面的方法：

#+BEGIN_EXAMPLE
#+FILETAGS: :Peter:Boss:Secret:
#+END_EXAMPLE

*** 6.2 设置标签
在标题后可以很容易地输入标签。在冒号之后，M-TAB 可以补全标签。也有一些专门的命令用于输入标签：

| C-c C-q | 	为当前标题输入标签。Org 模式既支持补全，也支持单键接口来设置标签，见下文。回车之后，标签会被插入，并放到第 org-tags-column 列。如果用前缀 C-u，会把当前缓冲区中的所有标签都对齐到那一列，这看起来很酷。 |
| C-c C-c | 	当光标处于标题上时，这个命令同C-c C-q。                                                                                                                                                                 |

Org 支持基于一个标签列表来插入标签。默认情况这个列表是动态构建的，包含了当前缓冲区中使用过的所有标签。
你也可以通过变量 org-tag-alist 在全局设定一个标签的硬列表（hard list）。
另外，对于某个特定文件你也可以用下面这几行设置一个默认列表：

#+BEGIN_EXAMPLE
#+TAGS: @work @home @tennisclub
#+TAGS: laptop car pc sailboat
#+END_EXAMPLE

默认 Org 模式用一个迷你缓冲区补全设施来输入标签。另外，它也实现了一个更快速，称为 快速标签选择 （ fast tag selection ）的标签选择方法。
这使得你只用按一次键就可以选择或者取消一个标签。为了使它能很好地工作，需要为常用的标签赋唯一的值。
你可以在你的“.emacs”文件中通过设置变量 org-tag-alist 作全局设定。
例如，如果你需要在不同的文件中经常要给条目添加标签“:@home:”，这时你就可以像这样设置：

#+BEGIN_EXAMPLE
(setq org-tag-alist '(("@work" . ?w) ("@home" . ?h) ("laptop" . ?l)))
#+END_EXAMPLE

如果标签只用于当前正在处理的文件，那么你可以这样设置标签选项行：

#+BEGIN_EXAMPLE
#+TAGS: @work(w) @home(h) @tennisclub(t) laptop(l) pc(p)
#+END_EXAMPLE

*** 6.3 标签查找
一旦标签体系设置好，就可以用来收集相关联的信息到指定列表中。

| C-c \   |                                                                                                                                 |
| C-c / m | 	用匹配标签搜索的所有标题构造一个稀疏树。带前缀参数C-u时，忽略所有还是TODO行的标题。                                     |
| C-c a m | 	用所有议程文件匹配的标签构造一个全局列表。见第 10.3.3 节。                                                              |
| C-c a M | 	用所有议程文件匹配的标签构造一个全局列表，但只搜索 TODO 项，并强制搜索所有子项（见变量 org-tags-match-listsublevels）。 |

这些命令都会提示输入字符串，字符串支持基本的逻辑去处。像“+boss+urgent-project1”，是搜索所有的包含标签“boss”和“urgent”但不含“project1”的项；
而 “Kathy|Sally”，搜索标签包含“Kathy”或者“Sally”和项。搜索字符串的语法很丰富，支持查找TODO关键字、条目级别和属性。更详细的介绍和例子，见第 10.3.3 节

** 7 属性
属性是一些与条目关联的键值对。它们位于一个名为 PROPERTIES 的特殊抽屉中。第一个属性都单独一行，键在前（被冒号包围），值在后：

#+BEGIN_EXAMPLE
 * CD collection
 ** Classic
 *** Goldberg Variations
    :PROPERTIES:
    :Title:    Goldberg Variations
    :Composer: J.S. Bach
    :Publisher: Deutsche Grammophon
    :NDisks:   1
    :END:
#+END_EXAMPLE

通过设置属性 “:Xyz_ALL:” ，你可以为属性 “:Xyz:” 设置所有合法的值。这个特定的属性是有 继承性 的，
即，如果你是在第 1 级别设置的，那么会被应用于整个树。当合法的值设定之后，设置对应的属性就很容易了，并且不容易出现打字错误。
用CD唱片集为例，我们可以预定义发行商和盒中的光盘数目：
#+BEGIN_EXAMPLE
 * CD collection
  :PROPERTIES:
  :NDisks_ALL: 1 2 3 4
  :Publisher_ALL: "Deutsche Grammophon" Philips EMI
  :END:
#+END_EXAMPLE

也可以在全局设置 org-global-properties ，或者在文件级别设置：
#+BEGIN_EXAMPLE
#+PROPERTY: NDisks_ALL 1 2 3 4
#+END_EXAMPLE

| C-c C-x p | 	设置一个属性。会询问属性名和属性值。 |
| C-c C-c d | 	从当前项中删除一个属性。             |
|           |                                              |

要基于选择的属性创建稀疏树或者特殊列表，跟标签搜索的命令相同（见第6.3节）。搜索字符串的语法在第10.3.3节中详述。

** 8 日期和时间
为了支持工程的计划，TODO 项可以标记上日期和/或时间。带有日期和时间信息的特定格式的字符串在 Org 模式中称为时间戳。

*** 8.1 时间戳
时间戳是一个具有特定格式的日期（可能带有时间和时间段）说明，例如 ~ 2005-10-01~ Tue ， ~ 2003-09-16~ Tue 09:39 ，
或者 ~ 2003-09-16~ Tue 12:00-12:30 。 
时间戳可以出现在树条目的标题和正文的任何地方。它能使条目只在特定的日期才出现在议程列表中。（见第 10.3.1 节）我们区分为：

**** 普通时间戳；事件；约会

一个简单的时间戳只是给一个条目加上时间和日期。这跟在纸质的议程上写下约会和事件是一样的。

#+BEGIN_EXAMPLE
 * Meet Peter at the movies <2006-11-01 Wed 19:15>
 * Discussion on climate change <2006-11-02 Thu 20:00-22:00>
#+END_EXAMPLE

**** 具有时间间隔的时间戳

一个时间戳可以包含一个时间间隔，表示事件不只在指定的时间发生，还在每隔一个特定的时间如 N 天（d）、周（w）、月（m）或者年（y）之后重复发生。
下面的事件每周二在议程中显示：

#+BEGIN_EXAMPLE
 * Pick up Sam at school <2016-02-03 周三 12:30 +1w>
#+END_EXAMPLE

**** 日记样式的 sexp 条目

为了能定义更复杂的时间，Org 模式支持 Emacs 日历/日记包（calendar/diary package）中的日记条目。例如：
#+BEGIN_EXAMPLE
 * The nerd meeting on every 2nd Thursday of the month
  <%%(diary-float t 4 2)>
#+END_EXAMPLE

**** 时间/日期段

两个时间戳用‘–’连接起来就定义了一个时间段：
#+BEGIN_EXAMPLE
 * Meeting in Amsterdam
   <2004-08-23 Mon>--<2004-08-26 Thu>
#+END_EXAMPLE

**** 非激活的时间戳

跟普通时间戳一样，但是这里是方括号而不是尖括号。这种时间戳是未激活的，它 不 会让一个条目显示在议程中。
#+BEGIN_EXAMPLE
 * Gillian comes late for the fifth time [2006-11-01 Wed]
#+END_EXAMPLE

*** 8.2 创建时间戳
时间戳要有特定的格式，这样才能被Org模式识别。下面的命令可以用来正确地处理时间戳的格式。

| C-c .        | 	询问日期并输入正确的时间戳。当光标处理一个时间戳之上时，是修改这个时间戳，而不是插入一个新的。如果这个命令连用再次，就会插入一个时间段。加上前缀会附带当前时间。                                                   |
| C-c !        | 	功能同C-c .，但是插入的是一个未激活的时间戳。                                                                                                                                                                      |
| S-LEFT/RIGHT | 	将光标处理的时间戳改变一天。                                                                                                                                                                                       |
| S-UP/DOWN    | 	改变时间戳中光标下的项。光标可以处在年、月、日、时或者分之上。当时间戳包含一个时间段时，如 “15:30-16:30”，修改第一个时间，会自动同时修改第二个时间，以保持时间段长度不变。想修改时间段长度，可以修改第二个时间。 |
 
当 Org 模式询问时间/日期时，能接收任何包含时间和/或日期的字符串，它能根据当前的时间日期智能地分析字符串，从而得到没有指明的信息。
你也可以用弹出的日历中选择日期。想完整地了解时间/日期询问的工作方式，可以参考手册

*** 8.3 截止期限和计划安排
时间戳前面可以加一些关键字来协助计划安排。

**** 截止期限

意义：任务（大多数情况都会是一个TODO项，当然也可以不是）应该完成的日期。

|C-c C-d|在标题下面一行插入一个带有“DEADLINE”关键字的时间戳。|

在 截止日期 ， 任务 会列在 议程 中。另外， 今天的议程 会在任务到期 orgdeadline-warning-days 天前对即将即将到期以及已经过期的任务给出提醒，直到任务被标记为 DONE。
例如：
#+BEGIN_EXAMPLE
 *** TODO write article about the Earth for the Guide
    The editor in charge is bbdb:Ford Prefect
    DEADLINE: <2004-02-29 Sun>
#+END_EXAMPLE

**** 日程安排

意义：你计划在给定的那个日期开始进行那项任务。

| C-c C-s | 在标题下面插入一个带有“SCHEDULED”关键字的时间戳。 |

在给定的日期标题会列在议程中。另外，对于过期的日程安排会在编辑为 今天 并给出提醒，直到被标记为 DONE。也就是说，任务会自动推迟日期直到它被完成。

#+BEGIN_EXAMPLE
 *** TODO Call Trillian for a date on New Years Eve.
    SCHEDULED: <2004-12-25 Sat>
#+END_EXAMPLE

有些任务需要一再重复出现。Org 模式在截止期限、计划安排和普通时间戳中用所谓的中继器来管理这种任务。在下面的例子中：

#+BEGIN_EXAMPLE
 ** TODO Pay the rent
   DEADLINE: <2005-10-01 Sat +1m>
#+END_EXAMPLE

+1m 是一个中继器；上面的意思是任务有一个截止期限 ~ 2005-10-01~ ，并从这个日期开始每月都重复出现。

*** 8.4 记录工作时间
使用 Org 可以记录在一个工程中花在某些特定任务上的时间。

| C-c C-x C-i     | 开始当前条目的计时（clock-in）。这会插入一个 CLOCK 关键字和一个时间戳。加上 C-u 前缀，从当前已经计时的任务中选择任务。 |   |
| C-c C-x C-o     | 停止计时（clock-out）。这会在开始计时的地方插入另一个时间戳。它会直接计算使用时间并插入到时间段的后面如 “=> HH:MM”。 |   |
| C-c C-x C-e     | 为当前的计时任务更新进度。                                                                                             |   |
| C-c C-x C-x     | 取消当前的计时。当你误操作打开一个计时时，或者转而去做其他事情时，这个命令就很有用。                                   |   |
| C-c C-x C-j     | 跳转到包含当前正在运行的计时的任务条目。用 C-uf前缀从当前计时的任务中选择。                                            |   |
| C-c C-x C-r     | 在当前文件插入一个包含像 Org 表格一样的计时报告的动态块。当光标正处于一个存在的块上时，更新它。                        |   |
|                 | #+BEGIN: clocktable :maxlevel 2 :emphasize nil :scope file                                                             |   |
|                 | #+END: clocktable                                                                                                      |   |
|                 | 如何定制视图，见手册                                                                                                   |   |
| C-c C-c	 | 在一个已经存在的计时表格之上时，更新它。 更新动态块。光标需要置于动态块 #+BEGIN 这行。                                 |   |
"/"键可能会在时间轴（见第 10.3.4 节）和议程（见第 10.3.1 节）中使用来查看一天中处理和关闭了哪些任务。
** TODO 9 捕获——转发——存档
任何组织系统都有一个重要功能，就是能捕获新的灵感或者任务，并将相关的引用材料与之联系起来。Org 提供了一个捕获过程来创建任务。
它将与一个任务相关的文件（附件）保存在一个特定的目录下。在系统中，任务和项目经常移动。将整个项目树保存到一个归档文件中可以保持系统简洁快速。

*** 9.1 捕获
Org 的获取一个新条目的方法很大程序上受 John Wiegley 的 excellent remem-ber package 的影响。
它使得你可以在工作流程中中断一小会儿来存贮一个简短的笔记。Org可以为新条目定义模板，并将它们与不同的目标文件关联起来以保存笔记。

**** 设定截取位置

下面的定制为笔记设置了一个默认的目标文件，并为捕获新的任务定义了一个全局快捷键。
#+BEGIN_EXAMPLE
(setq org-default-notes-file (concat org-directory "/notes.org"))
(define-key global-map "\C-cc" 'org-capture)
#+END_EXAMPLE

**** 截取的使用

| C-c c   | 启动一个捕获过程。进入一个窄的间接缓冲区来编辑条目。                   |
| C-c C-c | 一旦完成捕获信息的输入，可以用C-c C-c 返回之前的窗口，继续中断的工作。 |
| C-c C-w | 将条目保存到一个接收地址（见第2节）并结束。                            |
| C-c C-k | 取消捕获过程，返回之前的状态。                                         |

**** 捕获模板

用可以用不同的模板来做不同的捕获笔记，并将它们保存到不同的地方。
例如，你想将新任务保存到文件“TODO.org”的“Tasks”标题下，而将日记项目保存到“journal.org”中一个时间树中。
你可以：
#+BEGIN_EXAMPLE
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
         "* TODO %?\n %i\n %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
         "* %?\nEntered on %U\n %i\n %a")))
#+END_EXAMPLE

其中，第一个字符串是模式的关键字，第二个字符串是简短的描述信息。接着是条目的类型和保存笔记的目标地址。
最后是模板本身，它利用%作转义符基于时间和上下文来填充一些信息。

当你调用 M-x org-capture 时，Org 提示输入一个键来选择模板（如果你有多个模板），然后就会给出像这样的内容：
#+BEGIN_EXAMPLE
 * TODO
 [[file:link to where you were when initiating capture]]
#+END_EXAMPLE

在扩展模板时，可以用%转义符进行动态地插入内容。下面是一些可以使用的项，查看手册获得更多的选项。11

| %a     | 注解，通常是由 org-store-link 创建的链接 |
| %i     | 初始化内容，当记忆时区域被C-u调用        |
| %t     | 时间戳，只是日期                         |
| %T     | 带有日期和时间的时间戳                   |
| %u，%U | 同上，但是时间戳不激活                   |

*** 9.2 转送笔记
当你回顾捕获的数据时，可以想把其中的一些条目转送到另一列表中，比如说到一工程项目。剪切，查找正确的地址，然后再粘贴笔记，这就似乎有些麻烦。
为了简化这个过程，可以用专门的命令：

| C-c C-w         | 	转送光标处的条目或者区域。这个命令会提供一些目标地址供选择,你可以通过补全功能选择一个。条目（或者区域中的所有条目）就会作为一个子项填充到目标标题下。 |
|                 | 默认情况下，当前缓冲区的一级标题会被作为转送的目标，你可以通过设置给出跨多个文件的复杂的定义。详见变量 org-refile-targets 的描述。                            |
| C-u C-c C-w     | 	借助于转送功能的接口来跳转到一个标题。                                                                                                                |
| C-u C-u C-c C-w | 	跳转到 org-refile 最后转送子树所到的地方。                                                                                                            |

*** 9.3 归档
当一个用（子）树表示的工程完成后，你可能想把它移走，不让它再在议程里显示。归档能使你的工作文件变得简洁，并能使议程视图构造等全局搜索保持高效。
最常用的归档命令是将工程树移到另一个文件——归档文件。

| C-c C-x C-a                  | 用变量 orgarchive-default-command 指定的命令归档当前的项。 |
| C-c C-x C-s 或者简化为 C-c $ | 将光标处的子树归档至 org-archive-location 指定的位置。     |

默认的归档位置是当前文件同目录下，名为当前文件名后加 “_archive” 的文件。例子和设置位置的方法见变量 org-archivelocation 的帮助信息。
下面是一个在缓冲区内设置该变量的方法：
#+BEGIN_EXAMPLE
#+ARCHIVE: %s_done::
#+END_EXAMPLE

** TODO 10 议程视图
根据 Org 的工作方式，TODO 项、时间戳和带标签的标题分散在一个或者多个文件中。
为了能够查看某一天的项目或者事件，信息必须收集在一起，以一种的有条理方式排序、显示。有几种不同的视图，见下文。

收集的信息在一个专门的议程缓冲区中显示。这个缓冲区是只读的，但是提供了一些命令可以访问原 Org 文件中对应的条目，并且可以远程地编辑这些文件。
从议程缓冲区中远程编辑是说，比如，你可以在议程缓冲区中改变标题和约会的日期。议程缓冲区中使用的命令在第 10.4 节列出。

*** 10.1 议程文件
显示的信息通常是从各个议程文件中收集来的，这样文件在变量 org-agenda-files 中列出。你可以在你的emacs初始化文件(.emacs)里加入如下几行：
#+BEGIN_EXAMPLE
 (setq org-agenda-files (list "~/org/work.org"
                            "~/org/school.org"
                             "~/org/home.org"))
#+END_EXAMPLE

| C-c [ | 将当前文件加入到议程文件列表中。当前文件会被加到列表的前面。如果文件已经在列表中，会被移到前面。带有前缀时，文件添加/移到到后面。 |
| C-c ] | 将当前文件从议程文件列表中删除。                                                                                                  |
| C-,   | 遍历议程文件列表，依次访问其中的每一个文件。                                                                                      |

*** 10.2 议程调度器
视图是通过议程调试器创建的，通常我们会给它设置一个全局快捷键——比如 C-c a （见第1.2节）。按 C-c a 之后，就会提示再输入一个字母来执行对应的命令：

| a   | 日历式的议程。（见 10.3.1）                   |
| t/T | TODO 项的列表。（见 10.3.2节）                |
| m/M | 匹配某个标签表达式的标题的列表。（见 10.3.3） |
| L   | 当前文件的时间轴视图。（见 10.3.4）           |
| s   | 通过关键字和/或正则表达式选中的条目的列表。   |

*** 10.3 内建议程视图
**** 10.3.1 周/日议程
周/日议程就像纸质的议程一样，用以显示本周或当天的所有任务。

| C-c a a | 从一列 Org 文件中为本周收集出一个议程。议程显示出每天的条目。 |

Emacs 包含了 Edward M. Reingold 的日历和日记功能。Org 模式能识别日记的语法并允许在 Org 文件中直接使用日记的 sexp 条目：
#+BEGIN_EXAMPLE
 * Birthdays and similar stuff
#+CATEGORY: Holiday
  %%(org-calendar-holiday) ; special function for holiday names
#+CATEGORY: Ann
  %%(diary-anniversary 5 14 1956) Arthur Dent is %d years old
  %%(diary-anniversary 10 2 1869) Mahatma Gandhi would be %d years old
#+END_EXAMPLE

Org 可以跟 Emacs 的约会提醒功能结合。想添加议程文件中的约会提醒，可以使用命令 org-agenda-to-appt。详见帮助文档的描述。

**** 10.3.2 全局TODO列表
全局TODO列表将所有未完成的 TODO 项格式化并集中到一处。TODO 项的远程编辑使得我们只用按一下键就可以改变 TODO 项的状态。
TODO 列表中可以使用的命令在第10.4节给出。

| C-c a t | 显示全局 TODO 列表。这会从所有的议程文件（见第10章）中收集 TODO 项到一个缓冲区中。 |
| C-c a T | 同上，但可以选择 TODO 关键字                                                       |

**** 10.3.3 匹配标签和属性
如果议程文件中的标题带有标签（见第6章）或者带有属性（见第7章），就可以基于这些元数据筛选标题到议程缓冲区中。
这里描述的匹配语法在用 C-c / m 创建稀疏树时也同样适用。在标签列表中可以使用的命令在第10.4节描述。
#+BEGIN_EXAMPLE
C-c a m  将匹配指定的标签集的所有标题生成一个列表。这个命令询问筛选规则，可以是标签的逻辑表达式，如 “+work+urgent-withboss” 或 “work|home” （见第 6 章）。如果你经常使用某个搜索，可以将它定义成一个命令。（见第 10.2 节）
C-c a M  同 C-c a m，但只复选同时也是 TODO 项的标题。                                                                         
#+END_EXAMPLE

***** 匹配语法

搜索字符串可以使用 ‘&’ 作与运算， ‘|’ 作或运算。‘&’ 的约束力比 ‘|’ 的强。括号功能现在还没实现。
用以搜索的元素可以是标签 、匹配标签的正则表达式、或者像 PROPERTY OPERATOR VALUE 这样带有比较操作符的用来比较属性值的表达式。
第一个元素前面加 ‘-’ 表示不选匹配的项，加 ‘+‘ 表示选择匹配的项。使用 ’+‘ 和 ’-“ 时，与操作符 ‘&’ 就是可选的了。
这里有一些只使用标签的例子。
#+BEGIN_EXAMPLE
”+work-boss“               选择标有”:work:“的标题，但去掉同时也标有”:boss:“的标题。。
”work|laptop“              选择标有”:work:“或者”:laptop:“的行。
”work|laptop+night“        跟前面相同，但要求标有”:laptop:“和行也要标有”:night:“。
#+END_EXAMPLE
匹配标签时你也可以尝试同时匹配属性，详细内容见手册。

**** 10.3.4 单文件时间轴
时间轴用时间排序视图概述单个文件中的所有带有时间戳的条目。这个命令的目的是用来给出一个工程中事件的鸟瞰图。

| C-c a L | 给出 Org 文件中所有带时间戳条目的排序视图。带有 C-u 前缀时，没有完成的 TODO 项（作了安排的以及没作安排的）也列在当前日期下。 |

**** 10.3.5 查找视图
这个议程视图用来对 Org 模式下的条目进行普通的文本查找。对于查找笔记很有用。

| C-c a s | 这个查找方式可以让你通过匹配子串或者用逻辑表达式指定关键字来选择条目。 |

例如，查找字符串 ”computer equipment“ 将会查找包含子串 ”computer equipment“ 的条目。查找视图也可以用布尔逻辑查找条目中的关键字。
查找字符串 ”+computer +wifi -ethernet-{8\.11[bg]}“ 将会搜索包含关键字 computer 和 wifi 但不含 ethernet ，并且
不被正则表达式 8\.11[bg] （排除 8.11b 和 8.11g） 匹配的笔记条目。

注意，除了议程文件，这条命令也会搜索 org-agenda-text-search-extra-files 中列出的文件。

*** 10.4 议程缓冲区的命令
议程缓冲区中的条目链接到了它们的源 Org 或者日记文件。有一些命令可以用来显示和跳转到条目的源位置，也可以从视图缓冲区中”远程“编辑源文件。
下面只是所有命令的一个选集，浏览 Agenda 菜单和手册获得完整的列表。

**** 动作

| n | 下一行（同 DOWN 和 C-n）。 |
| p | 上一行（同 UP 和 C-p）。   |

**** 查看/转到 Org 文件

| mouse-3 |                                                                                |
| SPC     | 在另一个窗口中显示条目的源位置。带前缀使得整个条目在大纲中可见，而不只是标题。 |
| TAB     | 在另一个窗口中条目的源位置。在 Emacs 22 之前的版本，mouse-1 也有这个功能。     |
| RET     | 转到条目的源位置并删除其它的窗口。                                           |

**** 改变显示方式

| o              | 删除其他的窗口。                                                                                                                              |
| d / w          | 切换到日/周视图。                                                                                                                             |
| f 和 b         | 时间前移或者后移来显示随后的 org-agenda-current-span 天。例如，如果显示了一周的内容，切换到下/上一周。                                        |
| .              | 转到今天。                                                                                                                                    |
| j              | 询问日期并转到那天。                                                                                                                          |
| v l 或简化为 l | 触发日志模式（Logbook mode）。在日志模式中，当记录功能打开（变量 org-log-done）时标记为 DONE 的条目，以及在那天计时的条目，都会显示在议程中。 |
| r 或 g         | 重新构造议程，以反映最新的状态。                                                                                                              |
| s              | 保存当前 Emacs 会话的所有 Org 缓冲区和ID的地址。                                                                                              |

**** 二级筛选和查询编辑

| / | 根据标签过滤当前的缓冲区。提示你输入一个字母选择一个标签。先按‘-’排除一个标签。 |
| \ | 通过增加条件缩小当前议程的视图。                                                |

**** 远程编辑（参考手册获得更多命令）

| 0-9                  | 数字参数。                                                                              |
| t                    | 修改议程和 org 文件中的条目的TODO状态。                                                 |
| C-k                  | 删除当前的议程条目以及源文件中它的整个子树。                                            |
| C-c C-w              | 传送当前的条目。                                                                        |
| C-c C-x C-a 或简作 a | 用在 org-archive-default-command 中设置的默认归档命令对当前的条目对应的整个树进行归档。 |
| C-c C-x C-s 或简作 $ | 归档当前标题对应的树。                                                                  |
| C-c C-s              | 规划（Schedule）一个条目，带有前缀参数时删除规划时间戳。                                |
| C-c C-d              | 为条目设置截止期限，带前缀时删除截止期限。                                              |
| S-RIGHT 和 S-LEFT    | 将与当前行相关的时间戳改变一天。                                                        |
| I                    | 对当前条目开始计时。                                                                    |
| O / X                | 暂停/取消最近开始的计时。                                                               |
| J                    | 在另一个窗口中跳转到正在进行的计时。                                                    |

*** 10.5 定制议程视图
自定义搜索的主要用途是对于频繁使用的搜索进行快捷键绑定，从而快捷地创建议程缓冲区或者稀疏树（当然后者只涵盖当前缓冲区的内容）。
自定义的命令是用变量 org-agenda-custom-commands 来配置的。你可以用 C-c a C 来定制这个变量。也可以直接在 ”.emacs“ 中用 Emacs lisp 来设置。
下面的例子包含了所有合法的搜索类型：
#+BEGIN_EXAMPLE
(setq org-agenda-custom-commands
      '(("w" todo "WAITING")
        ("u" tags "+boss-urgent")
        ("v" tags-todo "+boss-urgent")))
#+END_EXAMPLE
每个项的首字符串是使用调度器命令 C-c a 之后要给出的键以使用相应的命令。通常都是单个字符。第二个参数是搜索类型，
接着是用来进行匹配的字符串或者正则表达式。上面的例子定义了：

| C-c a w | 对于包含关键字 ”“ 的 TODO 项的全局搜索。                             |
| C-c a u | 对于带有标签 ”:boss:“ 而不含标签 ”:urgent:“ 的标题的全局标签搜索。 |
| C-c a v | 同搜索 C-c a u，但搜索范围只限于同时也是 TODO 项的标题。               |

** 补全
Org 支持用 M-TAB 进行缓冲区内部的补全。这种补全不需要利用 minibuffer。你只需要键入几个字母然后用快捷键在原位补全。
例如，这个命令可以在‘\’后面补全 TeX 符号，在标题的开头补全 TODO 关键字，在‘:’之后补全标签。

** Link
用一个特殊的含有方括号的语法来表示链接：

#+BEGIN_EXAMPLE
[link(链接地址)][ description(链接描述)]]
#+END_EXAMPLE
生效后链接消失，只显示它的描述。移动光标到该链接上，按Ctrl-c和Ctrl-o，调用org-open-at-point。

你也能链接到本地文件。试试看浏览另外一个文件，比如说你的emacs初始化文件 (.emacs)，然后连续按Ctrl-c和l键调用org-store-link。
你会看到一条信息，说已经把你正在浏览的文件中的位置存为一个链接。
然后回到你的Org-Mode的buffer，用Ctrl-c和Ctrl-l来调出org-insert-link 来插入该链接。(你可以用方向键来翻查到你刚才记录的链接。)
** DONE hide more star, indent instead of star
- M-x org-indent-mode
- (setq org-startup-indented t);;in .emacs config
** TODO agenda view
*** custom agenda;
*** change status;

Switch to a daily view with d (org-agenda-day-view)
Switch to a weekly view with w (org-agenda-week-view)
View earlier or later days/weeks with your left and right arrow keys (org-agenda-earlier, org-agenda-later)
Jump to a specific day with j (org-agenda-goto-date)

A: all

Category:
P: project 一个工程项目对应一个以上的行动，并且它们通常都付有结束的日期。在各个工程项目的目录中记述项目的内容，换句话说就是细化项目流程。
   与任务的（Next Action）中说明的一样，也用一些动词来表述项目：
   完成，决定，处理，调查，提示，扩大，计划，设计，结束，确定，查询，展开，更新，安装，改良，设定。
F: financial 财务相关
C: calendar 特殊日期
T: tasks todo list 使用明确的动词表示“next action”，例如：
   处理，提问，回避，购买，变更，明确，收集，委托，从事，深思，想象，决定，延期，开发，废弃，重新实现，下载，输入，整理，跟踪，雇佣，
   改善，增加，报告，寻找，维持，测定，检测，订货，描画，打电话，设置优先级，购入，减少，记忆，修理，回复，调查，回顾，时间安排，卖，
   送，服务，指定，开始，停止，建议，规划，坐车，更新，升级，写。

Property:
SEQ_TODO: TODO(t) STARTED(s) WAITING(w) APPT(a) | DONE(d) CANCELLED(c) DEFERRED(f)

Tag:
O: office
H: home
R: reading 正在读的书
B: book 计划读的书

** TODO remember or capture mode
*** add log or capture info for remember; 
** TODO plannerMode
*** add schedule;
** TODO list or find something by label(attribute) or key(organize by projectile?)
** save and display pictures
** save web page and view offline.



[[http://www.cnblogs.com/holbrook/archive/2012/04/12/2444992.html][org-mode: 最好的文档编辑利器，没有之一]]
[[http://holbrook.github.io/2012/04/14/emacs_orgmode_task.html][[Emacs学习笔记(10):Org-mode,最强的任务管理利器，没有之一]]
[[http://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html#sec-9][Org-mode 简明手册]]
[[http://www.cnblogs.com/holbrook/archive/2012/04/17/2454619.html][用Org-mode实现GTD]]
[[http://www.yifeiyang.net/emacs/use-emacs-org-mode.html][GTD实践---使用Emacs和Org-mode (quick links)]]
[[http://members.optusnet.com.au/~charles57/GTD/gtd_workflow.html][How I use Emacs and Org-mode to implement GTD]]
[[http://doc.norang.ca/org-mode.html][Org Mode - Organize Your Life In Plain Text!]]
[[https://github.com/marboo/orgmode-cn/blob/master/org.org][Org-Manual 7.8]]
[[[[https://dl.dropboxusercontent.com/u/3968124/sacha-emacs.html#unnumbered-46]]][Sacha Chua's Emacs configuration]]

